"use strict";
/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Test = exports.Suite = exports.Spec = void 0;
class Base {
    constructor(title, parent) {
        this._only = false;
        this.title = title;
        this.parent = parent;
    }
    titlePath() {
        if (!this.parent)
            return [];
        if (!this.title)
            return this.parent.titlePath();
        return [...this.parent.titlePath(), this.title];
    }
    fullTitle() {
        return this.titlePath().join(' ');
    }
}
class Spec extends Base {
    constructor(title, fn, suite) {
        super(title, suite);
        this.tests = [];
        this.testOptions = {};
        this.fn = fn;
        suite._addSpec(this);
    }
    ok() {
        return !this.tests.find(r => !r.ok());
    }
    _appendTest(runList, repeatEachIndex, retries) {
        const test = new Test(this);
        test.tags = runList.tags;
        test.retries = retries;
        test._runList = runList;
        test._workerHash = `${runList.index}#repeat-${repeatEachIndex}`;
        test._id = `${this._ordinal}@${this.file}::[${test._workerHash}]`;
        test._repeatEachIndex = repeatEachIndex;
        this.tests.push(test);
        return test;
    }
}
exports.Spec = Spec;
class Suite extends Base {
    constructor(title, parent) {
        super(title, parent);
        this.suites = [];
        this.specs = [];
        this._entries = [];
        this._hooks = [];
        this._annotations = [];
        if (parent)
            parent._addSuite(this);
    }
    _clear() {
        this.suites = [];
        this.specs = [];
        this._entries = [];
        this._hooks = [];
        this._annotations = [];
    }
    _addSpec(spec) {
        spec.parent = this;
        this.specs.push(spec);
        this._entries.push(spec);
    }
    _addSuite(suite) {
        suite.parent = this;
        this.suites.push(suite);
        this._entries.push(suite);
    }
    findTest(fn) {
        for (const suite of this.suites) {
            if (suite.findTest(fn))
                return true;
        }
        for (const spec of this.specs) {
            for (const test of spec.tests) {
                if (fn(test))
                    return true;
            }
        }
        return false;
    }
    findSpec(fn) {
        for (const suite of this.suites) {
            if (suite.findSpec(fn))
                return true;
        }
        for (const spec of this.specs) {
            if (fn(spec))
                return true;
        }
        return false;
    }
    findSuite(fn) {
        if (fn(this))
            return true;
        for (const suite of this.suites) {
            if (suite.findSuite(fn))
                return true;
        }
        return false;
    }
    totalTestCount() {
        let total = 0;
        for (const suite of this.suites)
            total += suite.totalTestCount();
        for (const spec of this.specs)
            total += spec.tests.length;
        return total;
    }
    _allSpecs() {
        const result = [];
        this.findSpec(test => { result.push(test); });
        return result;
    }
    _renumber() {
        // All tests are identified with their ordinals.
        let ordinal = 0;
        this.findSpec((test) => {
            test._ordinal = ordinal++;
        });
    }
    _hasOnly() {
        if (this._only)
            return true;
        if (this.suites.find(suite => suite._hasOnly()))
            return true;
        if (this.specs.find(spec => spec._only))
            return true;
    }
    _addHook(type, fn) {
        this._hooks.push({ type, fn });
    }
}
exports.Suite = Suite;
class Test {
    constructor(spec) {
        this.results = [];
        this.skipped = false;
        this.expectedStatus = 'passed';
        this.timeout = 0;
        this.annotations = [];
        this.tags = [];
        this.retries = 0;
        this.spec = spec;
    }
    status() {
        if (this.skipped)
            return 'skipped';
        // List mode bail out.
        if (!this.results.length)
            return 'skipped';
        if (this.results.length === 1 && this.expectedStatus === this.results[0].status)
            return 'expected';
        let hasPassedResults = false;
        for (const result of this.results) {
            // Missing status is Ok when running in shards mode.
            if (!result.status)
                return 'skipped';
            if (result.status === this.expectedStatus)
                hasPassedResults = true;
        }
        if (hasPassedResults)
            return 'flaky';
        return 'unexpected';
    }
    ok() {
        const status = this.status();
        return status === 'expected' || status === 'flaky' || status === 'skipped';
    }
    _appendTestResult() {
        const result = {
            retry: this.results.length,
            workerIndex: 0,
            duration: 0,
            stdout: [],
            stderr: [],
            data: {}
        };
        this.results.push(result);
        return result;
    }
}
exports.Test = Test;
//# sourceMappingURL=test.js.map