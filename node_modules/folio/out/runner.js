"use strict";
/**
 * Copyright 2019 Google Inc. All rights reserved.
 * Modifications copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Runner = void 0;
const rimraf_1 = __importDefault(require("rimraf"));
const util_1 = require("util");
const dispatcher_1 = require("./dispatcher");
const util_2 = require("./util");
const test_1 = require("./test");
const multiplexer_1 = require("./reporters/multiplexer");
const removeFolderAsync = util_1.promisify(rimraf_1.default);
class Runner {
    constructor(loader, tagFilter) {
        this._loader = loader;
        this._reporter = new multiplexer_1.Multiplexer(loader.reporters());
        // This makes sure we don't generate 1000000 tests if only one spec is focused.
        const filtered = new Set();
        for (const { fileSuites } of loader.runLists()) {
            for (const fileSuite of fileSuites.values()) {
                if (fileSuite._hasOnly())
                    filtered.add(fileSuite);
            }
        }
        this._rootSuite = new test_1.Suite('');
        const grepMatcher = util_2.createMatcher(loader.config().grep);
        const nonEmptySuites = new Set();
        for (const runList of loader.runLists()) {
            if (tagFilter && !runList.tags.some(tag => tagFilter.includes(tag)))
                continue;
            for (const fileSuite of runList.fileSuites.values()) {
                if (filtered.size && !filtered.has(fileSuite))
                    continue;
                const specs = fileSuite._allSpecs().filter(spec => grepMatcher(spec.fullTitle()));
                if (!specs.length)
                    continue;
                fileSuite._renumber();
                const config = loader.config(runList);
                for (const spec of specs) {
                    for (let i = 0; i < config.repeatEach; ++i)
                        spec._appendTest(runList, i, config.retries);
                }
                nonEmptySuites.add(fileSuite);
            }
        }
        for (const fileSuite of nonEmptySuites)
            this._rootSuite._addSuite(fileSuite);
        filterOnly(this._rootSuite);
    }
    list() {
        this._reporter.onBegin(this._loader.config(), this._rootSuite);
        this._reporter.onEnd();
    }
    async run() {
        if (this._loader.config().forbidOnly) {
            const hasOnly = this._rootSuite.findSpec(t => t._only) || this._rootSuite.findSuite(s => s._only);
            if (hasOnly)
                return 'forbid-only';
        }
        const outputDirs = new Set();
        this._rootSuite.findTest(test => {
            outputDirs.add(this._loader.config(test._runList).outputDir);
        });
        await Promise.all(Array.from(outputDirs).map(outputDir => removeFolderAsync(outputDir).catch(e => { })));
        const total = this._rootSuite.totalTestCount();
        if (!total)
            return 'no-tests';
        const globalDeadline = this._loader.config().globalTimeout ? this._loader.config().globalTimeout + util_2.monotonicTime() : 0;
        const { result, timedOut } = await util_2.raceAgainstDeadline(this._runTests(this._rootSuite), globalDeadline);
        if (timedOut) {
            this._reporter.onTimeout(this._loader.config().globalTimeout);
            process.exit(1);
        }
        return result;
    }
    async _runTests(suite) {
        const dispatcher = new dispatcher_1.Dispatcher(this._loader, suite, this._reporter);
        let sigint = false;
        let sigintCallback;
        const sigIntPromise = new Promise(f => sigintCallback = f);
        const sigintHandler = () => {
            process.off('SIGINT', sigintHandler);
            sigint = true;
            sigintCallback();
        };
        process.on('SIGINT', sigintHandler);
        this._reporter.onBegin(this._loader.config(), suite);
        await Promise.race([dispatcher.run(), sigIntPromise]);
        await dispatcher.stop();
        this._reporter.onEnd();
        if (sigint)
            return 'sigint';
        return dispatcher.hasWorkerErrors() || suite.findSpec(spec => !spec.ok()) ? 'failed' : 'passed';
    }
}
exports.Runner = Runner;
function filterOnly(suite) {
    const onlySuites = suite.suites.filter(child => filterOnly(child) || child._only);
    const onlyTests = suite.specs.filter(spec => spec._only);
    if (onlySuites.length || onlyTests.length) {
        suite.suites = onlySuites;
        suite.specs = onlyTests;
        return true;
    }
    return false;
}
//# sourceMappingURL=runner.js.map