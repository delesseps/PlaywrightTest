"use strict";
/**
 * Copyright Microsoft Corporation. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Loader = void 0;
const transform_1 = require("./transform");
const util_1 = require("./util");
const spec_1 = require("./spec");
class Loader {
    constructor() {
        this._layeredConfigs = [];
        this._mergedConfig = {};
    }
    deserialize(data) {
        for (const config of data.configs) {
            if (typeof config === 'string')
                this.loadConfigFile(config);
            else
                this.addConfig(config);
        }
    }
    loadConfigFile(file) {
        const revertBabelRequire = transform_1.installTransform();
        try {
            require(file);
            this.addConfig(spec_1.configFile.config || {});
            this._layeredConfigs[this._layeredConfigs.length - 1].source = file;
            this.globalSetup = spec_1.configFile.globalSetup;
            this.globalTeardown = spec_1.configFile.globalTeardown;
        }
        catch (e) {
            // Drop the stack.
            throw new Error(e.message);
        }
        finally {
            revertBabelRequire();
        }
    }
    addConfig(config) {
        this._layeredConfigs.push({ config });
        this._mergedConfig = { ...this._mergedConfig, ...config };
    }
    loadTestFile(file) {
        const revertBabelRequire = transform_1.installTransform();
        spec_1.setCurrentFile(file);
        try {
            require(file);
        }
        catch (e) {
            util_1.prependErrorMessage(e, `Error while reading ${file}:\n`);
            throw e;
        }
        finally {
            spec_1.setCurrentFile();
            revertBabelRequire();
        }
    }
    config(runList) {
        if (!runList)
            return this._mergedConfig;
        return { ...this._mergedConfig, ...runList.config };
    }
    runLists() {
        return spec_1.configFile.runLists;
    }
    reporters() {
        return spec_1.configFile.reporters;
    }
    serialize() {
        return {
            configs: this._layeredConfigs.map(c => c.source || c.config),
        };
    }
}
exports.Loader = Loader;
//# sourceMappingURL=loader.js.map