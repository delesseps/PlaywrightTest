"use strict";
/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.setReporters = exports.globalTeardown = exports.globalSetup = exports.setConfig = exports.newTestTypeImpl = exports.mergeEnvsImpl = exports.configFile = exports.setCurrentFile = void 0;
const expect_1 = require("./expect");
const globals_1 = require("./globals");
const test_1 = require("./test");
const util_1 = require("./util");
Error.stackTraceLimit = 15;
let currentFile;
function setCurrentFile(file) {
    currentFile = file;
}
exports.setCurrentFile = setCurrentFile;
exports.configFile = { runLists: [], reporters: [] };
function mergeEnvsImpl(envs) {
    if (envs.length === 1)
        return envs[0];
    const forward = [...envs];
    const backward = [...forward].reverse();
    return {
        beforeAll: async (workerInfo) => {
            for (const env of forward) {
                if (env.beforeAll)
                    await env.beforeAll(workerInfo);
            }
        },
        afterAll: async (workerInfo) => {
            let error;
            for (const env of backward) {
                if (env.afterAll) {
                    try {
                        await env.afterAll(workerInfo);
                    }
                    catch (e) {
                        error = error || e;
                    }
                }
            }
            if (error)
                throw error;
        },
        beforeEach: async (testInfo) => {
            let result = undefined;
            for (const env of forward) {
                if (env.beforeEach) {
                    const r = await env.beforeEach(testInfo);
                    result = result === undefined ? r : { ...result, ...r };
                }
            }
            return result;
        },
        afterEach: async (testInfo) => {
            let error;
            for (const env of backward) {
                if (env.afterEach) {
                    try {
                        await env.afterEach(testInfo);
                    }
                    catch (e) {
                        error = error || e;
                    }
                }
            }
            if (error)
                throw error;
        },
    };
}
exports.mergeEnvsImpl = mergeEnvsImpl;
function newTestTypeImpl() {
    const fileSuites = new Map();
    let suites = [];
    function ensureSuiteForCurrentLocation() {
        const location = util_1.callLocation(currentFile);
        let fileSuite = fileSuites.get(location.file);
        if (!fileSuite) {
            fileSuite = new test_1.Suite('');
            fileSuite.file = location.file;
            fileSuites.set(location.file, fileSuite);
        }
        if (suites[suites.length - 1] !== fileSuite)
            suites = [fileSuite];
        return location;
    }
    function spec(type, title, options, fn) {
        if (!currentFile)
            throw util_1.errorWithCallLocation(`Test can only be defined in a test file.`);
        const location = ensureSuiteForCurrentLocation();
        if (typeof fn !== 'function') {
            fn = options;
            options = {};
        }
        const spec = new test_1.Spec(title, fn, suites[0]);
        spec.file = location.file;
        spec.line = location.line;
        spec.column = location.column;
        spec.testOptions = options;
        if (type === 'only')
            spec._only = true;
    }
    function describe(type, title, fn) {
        if (!currentFile)
            throw util_1.errorWithCallLocation(`Suite can only be defined in a test file.`);
        const location = ensureSuiteForCurrentLocation();
        const child = new test_1.Suite(title, suites[0]);
        child.file = location.file;
        child.line = location.line;
        child.column = location.column;
        if (type === 'only')
            child._only = true;
        suites.unshift(child);
        fn();
        suites.shift();
    }
    function hook(name, fn) {
        if (!currentFile)
            throw util_1.errorWithCallLocation(`Hook can only be defined in a test file.`);
        ensureSuiteForCurrentLocation();
        suites[0]._addHook(name, fn);
    }
    const modifier = (type, arg, description) => {
        if (currentFile) {
            const processed = util_1.interpretCondition(arg, description);
            if (processed.condition)
                suites[0]._annotations.push({ type, description: processed.description });
            return;
        }
        const testInfo = globals_1.currentTestInfo();
        if (!testInfo)
            throw new Error(`test.${type} can only be called inside the test`);
        testInfo[type](arg, description);
    };
    const test = spec.bind(null, 'default');
    test.expect = expect_1.expect;
    test.only = spec.bind(null, 'only');
    test.describe = describe.bind(null, 'default');
    test.describe.only = describe.bind(null, 'only');
    test.beforeEach = hook.bind(null, 'beforeEach');
    test.afterEach = hook.bind(null, 'afterEach');
    test.beforeAll = hook.bind(null, 'beforeAll');
    test.afterAll = hook.bind(null, 'afterAll');
    test.skip = modifier.bind(null, 'skip');
    test.fixme = modifier.bind(null, 'fixme');
    test.fail = modifier.bind(null, 'fail');
    test.runWith = (...args) => {
        let env = { beforeEach: () => { } };
        if (typeof args[0] === 'object' && args[0] && (args[0].beforeAll || args[0].beforeEach || args[0].afterAll || args[0].afterEach)) {
            env = args[0];
            args = args.slice(1);
        }
        const config = args[0] || {};
        const tag = 'tag' in config ? config.tag : [];
        exports.configFile.runLists.push({
            index: exports.configFile.runLists.length,
            fileSuites,
            env,
            tags: Array.isArray(tag) ? tag : [tag],
            config,
            testType: test,
        });
    };
    return test;
}
exports.newTestTypeImpl = newTestTypeImpl;
function setConfig(config) {
    // TODO: add config validation.
    exports.configFile.config = config;
}
exports.setConfig = setConfig;
function globalSetup(globalSetupFunction) {
    if (typeof globalSetupFunction !== 'function')
        throw util_1.errorWithCallLocation(`globalSetup takes a single function argument.`);
    exports.configFile.globalSetup = globalSetupFunction;
}
exports.globalSetup = globalSetup;
function globalTeardown(globalTeardownFunction) {
    if (typeof globalTeardownFunction !== 'function')
        throw util_1.errorWithCallLocation(`globalTeardown takes a single function argument.`);
    exports.configFile.globalTeardown = globalTeardownFunction;
}
exports.globalTeardown = globalTeardown;
function setReporters(reporters) {
    exports.configFile.reporters = reporters;
}
exports.setReporters = setReporters;
//# sourceMappingURL=spec.js.map